package node

import (
	"github.com/Contra-Culture/spg/data"
)

type (
	// Node is a page generator.
	// Nodes are organized in a tree, just like normal website pages.
	// Nested nodes inherit configuration from their parent node.
	// Nested nodes can redefine inherited configuration.
	Node struct {
		layout     []string
		screen     []string
		mainSchema string
		schemas    map[string]interface{} // interface{} is nil, []string or map[string]interface{}
		path       interface{}            // []string or func(*data.Object) []string
		children   map[string]*Node
	}
	NodeCfgr struct {
		key  string
		node *Node
		err  string
	}
)

// New() creates top-level Node.
func New(cfgs ...func(*NodeCfgr)) *Node {
	var (
		node = &Node{
			children: map[string]*Node{},
			schemas:  map[string]interface{}{},
			path: func(_ *data.Object) []string {
				return []string{"/"}
			},
		}
		nodeCfgr = &NodeCfgr{
			node: node,
		}
	)
	for _, cfg := range cfgs {
		cfg(nodeCfgr)
	}
	return node
}

// .Node() creates a child node.
func (c *NodeCfgr) Node(key string, cfg func(*NodeCfgr)) {
	node := &Node{
		children: map[string]*Node{},
		schemas:  map[string]interface{}{},
	}
	cfg(
		&NodeCfgr{
			key:  key,
			node: node,
		})
	c.node.children[key] = node
}

// .Path() specifies a paths fot the pages generated by the node.
// .Path() can apply []string, like: []string{"/"} for root page,
// or func(*data.Object)[]string - the function that calculates path
// for a particular data object, like a blog post, for example.
func (c *NodeCfgr) Path(rawPath interface{}) {
	if c.err != "" {
		return
	}
	if c.node.path != nil {
		c.err = "path is already specified"
		return
	}
	switch path := rawPath.(type) {
	case []string:
		c.node.path = path
	case func(*data.Object) []string:
		c.node.path = path
	default:
		c.err = "wrong path, should be of type []string or func(data.Object)[]string"
	}
}

// .Layout() - is an inheritable property, that specifies a layout template for the pages generated by the node.
func (c *NodeCfgr) Layout(path []string) {
	if c.err != "" {
		return
	}
	if c.node.layout != nil {
		c.err = "layout is already specified"
		return
	}
	c.node.layout = path
}

// .Screen() - is an inheritable property, that specifies a screen template for the pages generated by the node.
func (c *NodeCfgr) Screen(path []string) {
	if c.err != "" {
		return
	}
	if c.node.screen != nil {
		c.err = "screen is already specified"
		return
	}
	c.node.screen = path
}

// .MainSchema() - specifies non inheritable property, that sets relation between a pages generated by the node and a schema, when a path to a page is calculated depending on schema's object properties. For example, if main schema is a blog post, and all the blog posts have a slug, that slug property may be used for path calculation for the pages generated by the node.
func (c *NodeCfgr) MainSchema(n string) {
	if c.err != "" {
		return
	}
	if c.node.mainSchema != "" {
		c.err = "main schema is already specified"
		return
	}
	c.node.mainSchema = n
}

// .Schema() specifies the schema on which a content of the generated page depends on, but which has not effect on the page path.
func (c *NodeCfgr) Schema(path []string, links map[string]interface{}) {
	if c.err != "" {
		return
	}
	n := path[len(path)-1]
	c.node.schemas[n] = links
}
